<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="GrammerJack"/><link rel="canonical" href="https://jackpal.github.io/posts/2020/03/Building_an_image_board_browser"/><meta name="twitter:url" content="https://jackpal.github.io/posts/2020/03/Building_an_image_board_browser"/><meta name="og:url" content="https://jackpal.github.io/posts/2020/03/Building_an_image_board_browser"/><title>Building an image board browser using SwiftUI and Combine | GrammerJack</title><meta name="twitter:title" content="Building an image board browser using SwiftUI and Combine | GrammerJack"/><meta name="og:title" content="Building an image board browser using SwiftUI and Combine | GrammerJack"/><meta name="description" content="Building an image board browser using SwiftUI and Combine."/><meta name="twitter:description" content="Building an image board browser using SwiftUI and Combine."/><meta name="og:description" content="Building an image board browser using SwiftUI and Combine."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to GrammerJack"/></head><body class="item-page"><header><div class="wrapper"><a class="site-name" href="/">GrammerJack</a></div></header><div class="wrapper"><article><div class="content"><h1>Building an image board browser using SwiftUI and Combine</h1><p>As a hobby project, I've been writing an imageboard browser app to learn the SwiftUI and Combine libraries.</p><p>SwiftUI and Combine are available on many Apple platforms. So far I've gotten my imageboard browser working well on iPhone and iPad, and this weekend I got it working on Apple TV.</p><p>The iPhone and iPad run the same "Universal" app, which provides a vertical scrolling list and navigation stack UI that works well for both iPhone:</p><img src="KleeneStariPhone.jpg" alt="iPhone Screenshot"/><p>and iPad: <img src="KleeneStariPad.jpg" alt="iPad Screenshot"/></p><p>The AppleTV app looks and acts quite differently:</p><img src="KleeneStarTV.jpg" alt="AppleTV Screenshot"/><p>The AppleTV app has a "lean back" UI. The core feature of the AppleTV app is a slideshow mode. You start the app, use the remote to pick an image board, and then the app plays a slideshow of all the images on that board. There can be thousands of images on some of the more active boards. The slideshow repeats, picking up any updated content each time through.</p><p>I used an elaborate Combine pipeline to fetch the images. This is the heart of the pipeline:</p><pre><code><span class="comment">/// Combine Pipeline for Image Board Slideshow</span>

 <span class="keyword">public extension</span> <span class="type">Publisher</span> {
  
  <span class="comment">/// Perform requests after a delay.</span>
  <span class="keyword">func</span> slowRequest(delay: <span class="type">DispatchQueue</span>.<span class="type">SchedulerTimeType</span>.<span class="type">Stride</span>)
    -&gt; <span class="type">AnyPublisher</span>&lt;<span class="type">Self</span>.<span class="type">Output</span>, <span class="type">Self</span>.<span class="type">Failure</span>&gt; {
    <span class="keyword">var</span> firstItem = <span class="keyword">true
    let</span> serialQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"slowRequest"</span>)

    <span class="keyword">return self</span>
    .<span class="call">flatMap</span>(maxPublishers: .<span class="call">max</span>(<span class="number">1</span>)) { (item: <span class="type">Self</span>.<span class="type">Output</span>)
      -&gt; <span class="type">AnyPublisher</span>&lt;<span class="type">Self</span>.<span class="type">Output</span>, <span class="type">Self</span>.<span class="type">Failure</span>&gt; <span class="keyword">in
      if</span> firstItem {
        firstItem = <span class="keyword">false
        return</span> <span class="type">Just</span>(item)
          .<span class="call">setFailureType</span>(to: <span class="type">Self</span>.<span class="type">Failure</span>.<span class="keyword">self</span>).<span class="call">eraseToAnyPublisher</span>()
      }
      <span class="keyword">return</span> <span class="type">Just</span>(item)
        .<span class="call">setFailureType</span>(to: <span class="type">Self</span>.<span class="type">Failure</span>.<span class="keyword">self</span>)
        .<span class="call">delay</span>(for: delay, scheduler:serialQueue).<span class="call">eraseToAnyPublisher</span>()
    }
    .<span class="call">eraseToAnyPublisher</span>()
  }
  
  <span class="comment">/// Repeat the upstream publisher count times.</span>
  <span class="keyword">func</span> repeating(<span class="keyword">_</span> count: <span class="type">Int</span>) -&gt; <span class="type">AnyPublisher</span>&lt;<span class="type">Self</span>.<span class="type">Output</span>, <span class="type">Self</span>.<span class="type">Failure</span>&gt; {
    <span class="type">Publishers</span>.<span class="type">Sequence</span>(sequence: <span class="number">0</span>..&lt;count)
      .<span class="call">flatMap</span>(maxPublishers: .<span class="call">max</span>(<span class="number">1</span>)) { (_: <span class="type">Int</span>)
        -&gt; <span class="type">AnyPublisher</span>&lt;<span class="type">Self</span>.<span class="type">Output</span>, <span class="type">Self</span>.<span class="type">Failure</span>&gt; <span class="keyword">in
        return self</span>
      .<span class="call">eraseToAnyPublisher</span>()
    }
    .<span class="call">eraseToAnyPublisher</span>()
  }
  
}

<span class="comment">// Publishes all the images in a board.</span>
  <span class="keyword">func</span> publisher(board:<span class="type">BoardName</span>, targetLength: <span class="type">CGFloat</span>) -&gt; <span class="type">AnyPublisher</span>&lt;<span class="type">UIImage</span>?, <span class="type">Never</span>&gt; {
    <span class="type">FourChanService</span>.<span class="property">shared</span>.<span class="call">posts</span>(board:board)
    .<span class="call">filter</span> { post <span class="keyword">in</span>
      <span class="comment">// Filter out posts that don't have renderable images.</span>
      <span class="keyword">guard let</span> size = post.<span class="property">renderableImageSize</span> <span class="keyword">else</span> {
        <span class="keyword">return false</span>
      }
      <span class="comment">// Filter out posts where the renderable image is too small</span>
      <span class="keyword">return</span> <span class="call">min</span>(size.<span class="property">width</span>, size.<span class="property">height</span>) &gt;= targetLength/<span class="number">8</span>
    }
    <span class="comment">// When we get to the end of the stream, repeat.</span>
    .<span class="call">repeating</span>(<span class="type">Int</span>.<span class="property">max</span>)
    <span class="comment">// Slow down requests to the slideshow rate.</span>
    .<span class="call">slowRequest</span>(delay: <span class="number">5</span>)
    .<span class="call">flatMap</span>(maxPublishers: .<span class="call">max</span>(<span class="number">1</span>)) { post <span class="keyword">in</span>
        <span class="type">FourChanService</span>.<span class="property">shared</span>.<span class="call">dataPublisher</span>(endpoint:post.<span class="property">image</span>!)
        .<span class="call">map</span> {
          <span class="type">ImageDataInContext</span>(post:post, imageData:$0)
        }
    }
    .<span class="call">tryMap</span> {
      <span class="keyword">if let</span> image = <span class="call">downsample</span>(imageData:$0.<span class="property">imageData</span>, to: targetLength) {
        <span class="keyword">return</span> image
      }
      <span class="keyword">throw</span> <span class="type">ImageLoaderError</span>.<span class="property">couldNotDecodeImage</span>
    }
    .<span class="call">map</span> { <span class="type">Optional</span>($0) }
    .<span class="call">replaceError</span>(with: <span class="keyword">nil</span>)
    .<span class="call">receive</span>(on: <span class="type">DispatchQueue</span>.<span class="property">main</span>)
    .<span class="call">eraseToAnyPublisher</span>()
  }
}
</code></pre><p>This single animated view displays the slideshow:</p><pre><code><span class="type">A SwiftUI Slideshow View</span>
<span class="keyword">struct</span> TVSlideshowView : <span class="type">View</span> {
  <span class="keyword">let</span> publisher : <span class="type">AnyPublisher</span>&lt;<span class="type">UIImage</span>?, <span class="type">Never</span>&gt;
  
  <span class="keyword">@State private var</span> uiImageA: <span class="type">UIImage</span>? = <span class="keyword">nil
  @State private var</span> uiImageB: <span class="type">UIImage</span>? = <span class="keyword">nil
  @State private var</span> imageAHasPriority: <span class="type">Bool</span> = <span class="keyword">true
  
  var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">ZStack</span> {
      <span class="call">decorate</span>(uiImage: uiImageA, isImageA: <span class="keyword">true</span>)
      <span class="call">decorate</span>(uiImage: uiImageB, isImageA: <span class="keyword">false</span>)
    }
    .<span class="call">onAppear</span>() {
      <span class="type">UIApplication</span>.<span class="property">shared</span>.<span class="property">isIdleTimerDisabled</span> = <span class="keyword">true</span>
    }
    .<span class="call">onDisappear</span>() {
      <span class="type">UIApplication</span>.<span class="property">shared</span>.<span class="property">isIdleTimerDisabled</span> = <span class="keyword">false</span>
    }
    .<span class="call">onReceive</span>(publisher) { uiImage <span class="keyword">in
      self</span>.<span class="call">updateImages</span>(uiImage:uiImage)
    }
  }
  
  <span class="keyword">func</span> decorate(uiImage: <span class="type">UIImage</span>?, isImageA: <span class="type">Bool</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">Group</span> {
      <span class="keyword">if</span> uiImage != <span class="keyword">nil</span> {
        <span class="call">decorate</span>(uiImage: uiImage!, isImageA: isImageA)
      }
    }
  }
  
  <span class="keyword">func</span> decorate(uiImage: <span class="type">UIImage</span>, isImageA: <span class="type">Bool</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">GeometryReader</span> { proxy <span class="keyword">in</span>
      <span class="type">Image</span>(uiImage:uiImage)
        .<span class="call">renderingMode</span>(.<span class="dotAccess">original</span>)
        .<span class="call">resizable</span>()
        .<span class="call">aspectRatio</span>(contentMode: .<span class="dotAccess">fill</span>)
        .<span class="call">frame</span>(width:proxy.<span class="property">size</span>.<span class="property">width</span>, height:proxy.<span class="property">size</span>.<span class="property">height</span>)
        .<span class="call">animation</span>(<span class="keyword">nil</span>)
        .<span class="call">opacity</span>(<span class="keyword">self</span>.<span class="property">imageAHasPriority</span> == isImageA ? <span class="number">1.0</span> : <span class="number">0.0</span>)
        .<span class="call">animation</span>(.<span class="call">easeOut</span>(duration:<span class="number">0.6</span>))
    }
  }
  
  <span class="keyword">func</span> updateImages(uiImage: <span class="type">UIImage</span>?) {
    <span class="keyword">if</span> uiImage != <span class="keyword">nil</span> {
      imageAHasPriority.<span class="call">toggle</span>()
      <span class="keyword">if</span> imageAHasPriority {
        uiImageA = uiImage
      } <span class="keyword">else</span> {
        uiImageB = uiImage
      }
    }
  }
}
</code></pre><h1>Issues</h1><p>Although the code looks fairly clean now, I ran into some tricky problems while writing this code.</p><h2>Combine request throttling</h2><p>The slideshow makes multiple nested asynchronous requests to collect the image URLs:</p><pre><code>  repeatedly:
   request all the threads <span class="keyword">in</span> the image board:
     <span class="keyword">for</span> each thread, request all the posts <span class="keyword">in</span> the thread:
       <span class="keyword">for</span> each post, if it <span class="keyword">is</span> an image post, request the image data:
         decode the image data into a <span class="type">UIImage</span>
</code></pre><p>I ran into a problem where the earlier steps were not throttled, and so the image data was accumulating at a prodigious rate. I quickly exceeded the 2 GB memory limit for AppleTV apps.</p><p>Interestingly, if I displayed the images as quickly as possible, everything worked fine -- I ran the app for 20 minutes, displaying a new image every quarter of a second. Things only backed up when I changed the pipeline to work like this:</p><pre><code>  repeatedly:
   request all the threads <span class="keyword">in</span> the image board:
     <span class="keyword">for</span> each thread, request all the posts <span class="keyword">in</span> the thread:
       <span class="keyword">for</span> each post, if it <span class="keyword">is</span> an image post:
         request the image data:
           delay <span class="keyword">for</span> <span class="number">5</span> seconds:
             decode the image data into a <span class="type">UIImage</span>
</code></pre><p>In this pipeline, the image data accumulated in RAM, and that ended up killing the app.</p><p>Now Combine has the concept of back-pressure, and it's supposed to be possible to set up Combine pipelines so that this problem can be avoided. But unfortunately I couldn't get the backpressure to work in this pipeline. It might be due to my limited understanding, but it could also be due to a bug in Combine.</p><p>Luckily, I was able to work-around the issue by changing my pipeline to this:</p><pre><code>repeatedly:
  request all the threads <span class="keyword">in</span> the image board:
    <span class="keyword">for</span> each thread, request all the posts <span class="keyword">in</span> the thread:
      <span class="keyword">for</span> each post, if it <span class="keyword">is</span> an image post:
        delay <span class="keyword">for</span> <span class="number">5</span> seconds:
          request the image data:
            decode the image data into a <span class="type">UIImage</span>
</code></pre><p>By moving the "delay for 5 seconds" step before the "request the image data" step, I avoided backing up the pipeline.</p><h2>Image crossfading</h2><p>SwiftUI has an extensive animation system, but it isn't well documented, and it has bugs and limitations. I wasn't able to do exactly what I wanted, but I was at least able to get something working.</p><p>The effect I wanted was: Each time a new image is received, fade it in in front of the previous image. Ideally the opacity of the old image stays at 100%, while the new image's opacity animates from 0% (transparent) to 100% (opaque).</p><p>The effect I was able to achieve was: Each time a new image is received, fade it in in front of the previous image, while simultaneously fading the old image from 100% opacity to 0% opacity.</p><p>This works, but has the drawback that in the middle of the transition, both the old and new images are partially transparent, and so the background color shows through.</p><p>I tried a number of approaches to work around this problem, but I just couldn't get things to work.</p><p>Now that I've got basic crossfading working, I'm tempted to add "Ken Burns" style pan-and-zoom animation, as well as effects like the old AppleTV Photos screensaver.</p><h1>Conclusion</h1><p>For what it's worth, Apple's Instruments tool tells me there's some memory leaks when running the pipeline. These are genuine leaks, rather than retain cycles. The leaked objects appear to be internal to the SwiftUI implementation. Luckily the leaks are on the order of a few kilobytes per second, so it's not too much of a problem in practice.</p><p>I think Combine and SwiftUI are still "beta" quality software. Hopefully things will improve with iOS 14.</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/swiftui">SwiftUI</a></li><li><a href="/tags/combine">Combine</a></li></ul></article></div><footer><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>