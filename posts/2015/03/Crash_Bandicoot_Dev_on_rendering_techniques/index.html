<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="GrammerJack"/><link rel="canonical" href="https://jackpal.github.io/posts/2015/03/Crash_Bandicoot_Dev_on_rendering_techniques"/><meta name="twitter:url" content="https://jackpal.github.io/posts/2015/03/Crash_Bandicoot_Dev_on_rendering_techniques"/><meta name="og:url" content="https://jackpal.github.io/posts/2015/03/Crash_Bandicoot_Dev_on_rendering_techniques"/><title>Crash Bandicoot Dev on rendering techniques | GrammerJack</title><meta name="twitter:title" content="Crash Bandicoot Dev on rendering techniques | GrammerJack"/><meta name="og:title" content="Crash Bandicoot Dev on rendering techniques | GrammerJack"/><meta name="description" content="Jack Palevich's Essays"/><meta name="twitter:description" content="Jack Palevich's Essays"/><meta name="og:description" content="Jack Palevich's Essays"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to GrammerJack"/></head><body class="item-page"><header><div class="wrapper"><a class="site-name" href="/">GrammerJack</a></div></header><div class="wrapper"><article><div class="content"><h1>Crash Bandicoot Dev on rendering techniques</h1><p>As seen on Hacker News:</p><p><a href="https://news.ycombinator.com/item?id=9277704">Hacker News Comment by dmbaggett</a></p><p>Maybe Andy forgot to mention it; it's been a while since I've read the whole series.</p><p>The code was C and lisp so it didn't really require any effort to port other than replacing the rendering pipeline. And we used the SGIs to pre-render every frame anyway, to precompute the polygon sort order. (The PS1 had no Z-buffer, so you were stuck sorting polygons at run-time if you didn't do something clever.)</p><p>So we already had the rendering pipeline ported. Obviously you couldn't save your game to the memory card, etc. -- some stuff didn't work. But the game was playable (albeit very frustrating with keyboard controls).</p><p>Some day I will write this up for real, but without going into detail, here's a summary.</p><p>The camera in Crash was on a rail. It could rotate left, right, up, and down (in Crash 2 and beyond, at least), but could not translate except by moving forward/backward on the rail. This motivates a key insight: if you're only rotating the camera, the sort order of the polygons in the scene cannot change.</p><p>This allowed us to sample points on the rail and render the frame at each sample point ahead of time, as a batch job, on the SGI using a Z-buffer. (We may have done the Z-buffer with software; I don't remember.) Then we could recover the polygon order of each frame by looking at the Z-buffer. And, even better, at run-time we could simply <em>not render at all</em> those polygons that weren't ultimately visible in the pre-rendered scene. This solved both the sorting and clipping problem nicely, and made the look of the game closer to 3K polygons/frame vs. the 1K polygons we were actually rendering in real time. (Many polygons were occluded by other polygons.)</p><p>The trick, though, was what exactly to do with this sort/occlusion information. In a nutshell, what I did was write a custom delta-compression algorithm tailored to the purpose of maintaining the sorted polygon list from frame to frame, in R3000 assembly language. Miraculously, this ended up being quite feasible because the delta between frames was in practice very small -- a hundred bytes or so was typical. And if a transition was too heavyweight (i.e., the delta was too big) we'd either sample more finely in that area or tell the artists to take stuff out. :)</p><p>One thing nobody talks about but which is obvious in retrospect is that without a Z-buffer you're pretty screwed: sorting polygons is <em>not</em> O(N lg N) -- it's O(N^2). This is because polygons don't obey the transitivity property, because you can have cyclic overlap. (I.e., A &gt; B and B &gt; C does <em>not</em> imply A &gt; C). This is why virtually every game from that era has flickery polygons -- they were using bucket sorting, which has the advantage of being linear time complexity, but the disadvantage of being wrong, and producing this flickery effect as polygons jump from bucket to bucket between frames.</p><p>I'll leave the matter of weaving the foreground characters -- Crash himself and the other creatures -- into the pre-sorted background for another day.</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/playstation">Playstation</a></li><li><a href="/tags/3d">3D</a></li><li><a href="/tags/crash-bandicoot">Crash Bandicoot</a></li></ul></article></div><footer><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>